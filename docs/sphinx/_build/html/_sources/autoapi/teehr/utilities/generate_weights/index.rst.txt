:py:mod:`teehr.utilities.generate_weights`
==========================================

.. py:module:: teehr.utilities.generate_weights

.. autoapi-nested-parse::

   Module for generating area-based weights for grid layer pixels.

   ..
       !! processed by numpydoc !!


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   teehr.utilities.generate_weights.vectorize
   teehr.utilities.generate_weights.overlay_zones
   teehr.utilities.generate_weights.vectorize_grid
   teehr.utilities.generate_weights.calculate_weights
   teehr.utilities.generate_weights.generate_weights_file



.. py:function:: vectorize(data_array: xarray.DataArray) -> geopandas.GeoDataFrame

   
   Convert 2D xarray.DataArray into a geopandas.GeoDataFrame.











   .. rubric:: Notes

   Heavily borrowed from GeoCube, see:
   https://github.com/corteva/geocube/blob/master/geocube/vector.py#L12





   ..
       !! processed by numpydoc !!

.. py:function:: overlay_zones(grid: geopandas.GeoDataFrame, zones: geopandas.GeoDataFrame) -> geopandas.GeoDataFrame

   
   Overlay zone polygons on vectorized grid cells.
















   ..
       !! processed by numpydoc !!

.. py:function:: vectorize_grid(src_da: xarray.DataArray, nodata_val: float, crs_wkt: str, vectorize_chunk: float = 40) -> geopandas.GeoDataFrame

   
   Vectorize pixels in the template array in chunks using dask.











   .. rubric:: Notes

   Parameter vectorize_chunk determines how many pixels will
   be vectorized at one time
   (thousands of pixels)





   ..
       !! processed by numpydoc !!

.. py:function:: calculate_weights(grid_gdf: geopandas.GeoDataFrame, zone_gdf: geopandas.GeoDataFrame, overlay_chunk: float = 250) -> geopandas.GeoDataFrame

   
   Overlay vectorized pixels and zone polygons, and calculate
   areal weights, returning a geodataframe.











   .. rubric:: Notes

   Parameter overlay_chunk determines the size of the rectangular
   window that spatially subsets datasets for the operation
   (thousands of pixels).





   ..
       !! processed by numpydoc !!

.. py:function:: generate_weights_file(zone_polygon_filepath: Union[pathlib.Path, str], template_dataset: Union[str, pathlib.Path], variable_name: str, output_weights_filepath: Union[str, pathlib.Path], crs_wkt: str, unique_zone_id: str = None, **read_args: Dict) -> None

   
   Generate a file of row/col indices and weights for pixels intersecting
      given zone polyons.


   :Parameters:

       **zone_polygon_filepath** : str
           Path to the polygons geoparquet file.

       **template_dataset** : str
           Path to the grid dataset to use as a template.

       **variable_name** : str
           Name of the variable within the dataset.

       **output_weights_filepath** : str
           Path to the resultant weights file.

       **crs_wkt** : str
           Coordinate system for given domain as WKT string.

       **unique_zone_id** : str
           Name of the field in the zone polygon file containing unique IDs.

       **\*\*read_args** : dict, optional
           Keyword arguments to be passed to GeoPandas read_file().
           read_parquet(), and read_feather() methods.











   .. rubric:: Examples

   Here we generate weights for grid pixels intersecting a given
   polygon(s). The algorithm accounts for the fraction of the pixel
   area that is within the polygon. We'll use the Nextgen divides/
   catchments as the polygons and a NWM v2.2 forcing file as the
   template grid.

   Import the necessary modules.

   >>> from teehr.utilities.generate_weights import generate_weights_file
   >>> from teehr.loading.nwm.const import CONUS_NWM_WKT

   Define the input variables.

   >>> TEST_DIR = Path("tests", "data", "nwm22")
   >>> TEMP_DIR = Path("tests", "data", "temp")
   >>> TEMPLATE_FILEPATH = Path(TEST_DIR, "test_template_grid.nc")
   >>> ZONES_FILEPATH = Path(TEST_DIR, "test_ngen_divides.parquet")
   >>> WEIGHTS_FILEPATH = Path(TEST_DIR, "test_weights_results.parquet")

   Perform the calculation, writing to the output directory, or optionally
   returning the dataframe if no output path is specified.

   >>> df = generate_weights_file(
   >>>     zone_polygon_filepath=ZONES_FILEPATH,
   >>>     template_dataset=TEMPLATE_FILEPATH,
   >>>     variable_name="RAINRATE",
   >>>     crs_wkt=CONUS_NWM_WKT,
   >>>     output_weights_filepath=None,
   >>>     unique_zone_id="id",
   >>> )



   ..
       !! processed by numpydoc !!

